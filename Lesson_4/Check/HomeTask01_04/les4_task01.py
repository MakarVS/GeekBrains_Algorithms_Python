# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
# Примечание. Идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать,
# b. написать 3 варианта кода (один у вас уже есть),
# c. проанализировать 3 варианта и выбрать оптимальный,
# d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
# e. написать общий вывод: какой из трёх вариантов лучше и почему.

# Была выбрана задача из домашнего задания №2:
#Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…

#1 Перый вариант - классический цикл

import timeit
import cProfile
from functools import lru_cache
def loop (n):

    result=0
    for i in range (n):

        result = result+ ((-0.5)**i)

    return result



#2 Второй вариант - Рекурсия и цикл. Первая функция (рекурсивная) определяет очередной элемент и передает во вторую фунцию для суммирования
def get_element(n):
    if n == 1:
        return 1

    return (-0.5) * get_element(n - 1)

@lru_cache ()
def recursion (n):
    sum=0
    for i in range (1,n+1):

        sum+=get_element(i)
    return sum



# третий вариант - Цикл и список. Испоьзуя генератор списков, создаем список из n элементов 1..-0.5...0.25.... Далее, используя вложенную функцию python находим
# сумму элементов списка.
def list(n):
    lst=[(-0.5)**(i) for i in range (n)]
    return (sum(lst))

#четвертый вариант - является развитием варианта 2, где рекурсивная функция сохраняет значение в список (меморизация)
def rec_list(n):
    rec_l=[None]*1000
    rec_l[0] = 1


    def _rec_list (n):

        if rec_l [n] is None:
            rec_l[n]=_rec_list (n-1)*(-0.5)

        return rec_l[n]

    return _rec_list(n)

def sum_rec_list (n):
     sum=0
     for i in range (1,n+1):
         sum+=rec_list(i-1)
     return (sum)

#n=8
#print ("Сумма элементов последовательности: ")

#print (loop (n))
#print (recursion(n))
#print (list(n))
#print (sum_rec_list(n))



# Далее улучшаем функцию  get_element из 2-го варианта решения при помощи functools

#Все результаты тестирования при помоще timeit и сProfile заностим в таблицу в формате Word, которую прилагаю отдельным файлом


#print (timeit.repeat("for x in range(100): recursion(x)", "from __main__ import recursion", number=1000))
cProfile.run ("recursion(50)")