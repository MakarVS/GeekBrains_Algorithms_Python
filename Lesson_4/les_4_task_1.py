# Задача № 1.
# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего
# задания первых трех уроков.
# Примечание. Идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать,
# b. написать 3 варианта кода (один у вас уже есть),
# c. проанализировать 3 варианта и выбрать оптимальный,
# d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать,
# для каких N вы проводили замеры),
# e. написать общий вывод: какой из трёх вариантов лучше и почему.

# Взята 3 задача из 2 урока:
# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, надо вывести 6843.

# Условие задачи было мной модифицировано (фактически с числами это работает также, не учтено только окончание числа
# на 0, делается это 2 строчками кода через if - если что я знаю, как это делается):
# Сделать реверс любой строки, приведенной на вход.

import cProfile


# Первая версия (изначальная)
def reverse_1(string, length, s):
    if length == 0:
        return s
    else:
        count = 1
        for let in string:
            if count == length:
                s += let
                length -= 1
                return reverse_1(string, length, s)
            else:
                count += 1


# Вторая версия (без рекурсии, с использованием индексов, но без срезов)
def reverse_2(string):
    s = ''
    ind = len(string)
    for i in range(ind - 1, -1, -1):
        s += string[i]
    return s


# Третья версия (максимальные возможности питона - использование срезов)
def reverse_3(string):
    return string[::-1]


# string = '123456789' * 100
# cProfile.run('reverse_1(string, len(string), "")')

# cProfile.run("reverse_2('123456789' * 100)")

# cProfile.run("reverse_3('123456789' * 100)")

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_1('123456789'*100, len('123456789'*1
# 00), '')"

# Результаты первой версии
# 100 loops, best of 5: 35.2 msec per loop
# 901/1    0.035    0.000    0.035    0.035 les_4_task_1.py:23(reverse_1)

# Сложность первого алгоритма по моему мнению минимум - O(2^n). Возможно O(n*2^n).

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_2('123456789'*100)"

# Результаты второй версии
# 100 loops, best of 5: 156 usec per loop
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:38(reverse_2)

# Сложность второго алгоритма по моему мнению - O(n^2). Так как O(n) занимает проход по массиу и столько же занимает
# конкатенация строк (в python это постоянное создание новой строки на основе двух предыдущих)

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_3('123456789'*100)"

# Результаты третьей версии
# 100 loops, best of 5: 2.72 usec per loop
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:47(reverse_3)

# Сложность третьего алгоритма - O(n)

'''
При анализе трех алгоритмов можно сделать следующие выводы:
1. Рекурсия работает медленно, к тому же ограничена глубиной в 1000 по-умолчанию.
На самом деле здесь огромный минус в питоновском цикле. Без использования индексов теряется возможность обратиться 
к любому элементу последовательности (в данном случае - строки).
2. Данный метод работает практически на 3 порядка быстрее. Использование индексов позволяет обращаться к любым элементам
последовательности.
3. Третий способ использует все возможности питона и позволяет получить реверс с помощью среза с отрицательным шагом.
Данный способ короче всех и быстрее в 57 раз, чем предыдущий. Предыдущий способ можно было реализовать на любом языке 
программирования, однако он занимает большее кол-во строк, чем последний. Данный способ является показательным для 
отображения сильных сторон питона. Питон позволяет тратить гораздо меньше времени на разработку, при этом часто проигрывая
в скорости из-за сложной внутренней структуры. 
Как говорится в дзене питона - "Красивое лучше, чем уродливое" и "Простое лучше, чем сложное", что и доказывает третья
реализация =)
'''