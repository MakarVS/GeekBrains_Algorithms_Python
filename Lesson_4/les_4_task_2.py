# Задача № 2.
# Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на
# вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Второй — без использования «Решета Эратосфена».

# Алгоритм с помощью решета Эрастофена

# Сложность алгоритма заключается в выборе начального списка натуральных чисел.
# Возьмем длину списка в виде удвоенного номера простого числа и будем составлять с помощью алгоритма Эрастофена
# список простых чисел. Далее пытаемся найти в нем нужное по счету число. Если такое число не найдено (индекс
# будет выходить за рамки массива), то увеличим размер списка в два раза и повторим действие до тех пор пока результат
# не будет достигнут.

import cProfile

# p = int(input('Введите порядковый номер простого числа: '))


def erast(p):
    sieve = [i for i in range(2*p+1)]

    while True:
        n = len(sieve)
        # Далее программная реализация алгоритма Эрастофена чисто в том виде, которая была дана на уроке
        sieve[1] = 0
        for i in range(2, n):
            if sieve[i] != 0:
                j = i * 2
                while j < n:
                    sieve[j] = 0
                    j += i
        result = [i for i in sieve if i != 0]
        # Проверка на существование нужного порядкового номера простого числа
        try:
            # В случае успеха выводим на экран и выходим из цикла
            return result[p-1]
            break
        except IndexError:
            # В случае ошибки формируем новый исходный список чисел (в 2 раза больше) и заново прогоняем алгоритм
            sieve = [i for i in range(2*n)]


# print(erast(p))
# cProfile.run('erast(500)')

# Я думаю, что сложность алгоритма - О(n*log(log(n)), т.е сложность алгоритма решета Эрастофена.
# Если же в исходном списке не найдено искомое простое число, то скорее всего в следующем оно будет найдено, т.е.
# сложность алгоритма умножается на какую-то константу, которую можно откинуть.

# Для копирования в терминал:
# python -m timeit -n 100 -s "import les_4_task_2" "les_4_task_2.erast(500)"

# Результаты работы для 500-го простого числа:
# 100 loops, best of 5: 2.89 msec per loop
# 1    0.002    0.002    0.003    0.003 les_4_task_2.py:20(erast)

# Алгоритм с проверкой числа на простоту (проверка с линейной сложностью)

# i = int(input('Введите порядковый номер простого числа: '))


def main_lin(i):
    def check_simplicity(n):
        d = 2
        while n % d != 0:
            d += 1
        return d == n

    p = 1
    count = 0
    # Осуществляется проверка каждого натурального числа на простоту, если оно просто счетчик прибавляется
    while count <= i-1:
        p += 1
        if check_simplicity(p):
            count += 1
    return p


# print(main_lin(i))
# cProfile.run('main_lin(500)')

# Я думаю, что сложность алгоритма O(n^2). Так как сложность проверки на простоту каждого числа O(n)
# и пробегание по массиву натуральных чисел в одну сторону тоже занимает примерно O(n).

# Для копирования в терминал:
# python -m timeit -n 100 -s "import les_4_task_2" "les_4_task_2.main_lin(500)"

# Результаты работы для 500-го простого числа:
# 100 loops, best of 5: 89.6 msec per loop
#    1    0.001    0.001    0.126    0.126 les_4_task_2.py:63(main_lin)
# 3570    0.124    0.000    0.124    0.000 les_4_task_2.py:64(check_simplicity)


# Оптимизируем алгоритм проверки на простоту. Уменьшим его сложность до O(sqrt(n)).

def main_sqrt(i):
    def check_simplicity(n):
        d = 2
        while d * d <= n and n % d != 0:
            d += 1
        return d * d > n

    p = 1
    count = 0
    while count <= i-1:
        p += 1
        if check_simplicity(p):
            count += 1
    return p


# print(main_sqrt(i))
# cProfile.run('main_sqrt(500)')

# Общая сложность алгоритма тогда будет являться O(n*sqrt(n)).

# Для копирования в терминал:
# python -m timeit -n 100 -s "import les_4_task_2" "les_4_task_2.main_sqrt(500)"

# Результаты работы для 500-го простого числа:
# 100 loops, best of 5: 5.24 msec per loop
#    1    0.001    0.001    0.006    0.006 les_4_task_2.py:97(main_sqrt)
# 3570    0.005    0.000    0.005    0.000 les_4_task_2.py:98(check_simplicity)

# Как видно из профайлера, скорость работы функции проверки на простоту изрядно повысилась.
# Однако из-за более низкой сложности алгоритма решета Эрастофена - он показал себя гораздо лучше.
# Для более наглядного понимания различной сложности можно посмотреть на графики функций в О символике
# (расскоментируйте и запустите следующий код)

# from matplotlib import pyplot as plt
# import numpy as np
#
# x = np.arange(2, 100, 1)
#
# y_1 = x*np.emath.log(np.emath.log(x))
# y_2 = x*np.sqrt(x)
# y_3 = x**2
#
# plt.plot(x, y_1, label='erast')
# plt.plot(x, y_2, label='sqrt')
# plt.plot(x, y_3, label='lin')
#
# plt.legend()
# plt.show()
